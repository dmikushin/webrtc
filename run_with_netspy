#!/usr/bin/env python3

import subprocess
import threading
import sys
import os
import signal
import shutil
import argparse
import time

# Configuration
CARGO_BUILD_COMMAND = "cargo build"

CMAKE_PROJECTS_TO_BUILD = [
    {
        "name": "signalling-server",
        "source_dir": "examples/signalling-server",
        "cmake_target_name": "signalling-server",
        "executable_relative_path": "signalling-server"
    },
    {
        "name": "vtk_cube",
        "source_dir": "examples/examples/vtk-cube",
        "cmake_target_name": "vtk_cube",
        "executable_relative_path": "vtk_cube"
    }
]

CMAKE_BUILD_DIR = "build" # Top-level build directory where project-specific builds will reside
CMAKE_CONFIG_ARGS = ["-DCMAKE_BUILD_TYPE=Debug"] # Add other CMake config args if needed e.g. ["-G", "Ninja"]

EXECUTABLE_RUN_CONFIG = [
    {
        "id": "signalling-server",
        "type": "cmake",
        "args": ["--verbose", "--port", "8888"],
        "prefix": "[signalling server] "
    },
    {
        "id": "vtk_cube", # Server
        "type": "cmake",
        "args": ["--native", "--webrtc", "--verbose", "--signalling", "ws://localhost:8888"],
        "prefix": "[server] "
    },
    {
        "id": "vtk-cube-client-console",
        "type": "cargo_example",
        "cargo_profile": "debug", # Must match CARGO_BUILD_COMMAND profile
        "args": [],
        "prefix": "[client] "
    }
]

# Global list to keep track of Popen objects for cleanup
processes_to_cleanup = []

# NetSpy configuration - using CLI frontend now
NETSPY_CMD = "netspy"

def run_build_command(command_list, description, cwd=None):
    try:
        print(f"{description}...")
        process = subprocess.run(command_list, check=True, capture_output=True, text=True, cwd=cwd)
        print(f"{description}: Completed successfully")
        if process.stdout:
            print(f"{description} stdout: {process.stdout}")
        if process.stderr:
            print(f"{description} stderr: {process.stderr}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"{description}: FAILED with exit code {e.returncode}")
        if e.stdout:
            print(f"{description} stdout: {e.stdout}")
        if e.stderr:
            print(f"{description} stderr: {e.stderr}")
        return False

def read_and_prefix_output(process, prefix):
    """Reads output from a process, prefixes it, and prints it."""
    try:
        for line in process.stdout: # stdout includes stderr due to Popen redirect
            sys.stdout.write(prefix + line)
            sys.stdout.flush()
        process.wait() # Wait for the process to finish if stdout closes early
        if process.returncode != 0 and process.returncode is not None : # Check for None if process was terminated by signal
             # Avoid double printing if already handled by signal_handler's process check
            if not (hasattr(process, '_terminated_by_signal') and process._terminated_by_signal):
                sys.stderr.write(f"{prefix}exited with error code {process.returncode}\n")
    except Exception as e:
        # Check if the error is due to reading from a closed pipe after termination
        if process.poll() is not None: # Process has terminated
            pass # Suppress error if process is already dead (likely terminated by signal_handler)
        else:
            sys.stderr.write(f"{prefix}Error reading output: {e}\n")

def signal_handler(sig, frame):
    """Signal handler for SIGINT and SIGTERM to clean up child processes."""
    sys.stderr.write("\nInterrupt or timeout received, terminating processes...\n") # Modified message
    for p in reversed(processes_to_cleanup):
        if p.poll() is None:
            try:
                p._terminated_by_signal = True # Mark for read_and_prefix_output
                p.terminate()
            except Exception as e:
                sys.stderr.write(f"Error terminating process {p.pid}: {e}\n")
    
    # Give some time for processes to terminate
    terminated_cleanly = True
    for p in reversed(processes_to_cleanup):
        if p.poll() is None:
            try:
                p.wait(timeout=2)
                if p.poll() is None:
                    p.kill()
                    sys.stderr.write(f"Process {p.pid} killed.\n")
                    terminated_cleanly = False
            except Exception as e:
                sys.stderr.write(f"Error waiting/killing process {p.pid}: {e}\n")
                terminated_cleanly = False
    
    if not terminated_cleanly:
        sys.exit(1) # Exit with error if force kill was needed
    else:
        print("All processes terminated gracefully.")
        sys.exit(0) # Exit cleanly if all terminated or were already done

def main():
    parser = argparse.ArgumentParser(description="Run and manage the WebRTC pipeline with NetSpy network tracing.")
    parser.add_argument("--timeout", type=int, default=30, help="Duration in seconds to run the processes before shutting them down. Default is 30 seconds.")
    parser.add_argument("--no-netspy", action="store_true", help="Run without NetSpy tracing")
    args = parser.parse_args()

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # Check if NetSpy CLI is available (assuming it's installed separately)
    if not args.no_netspy:
        try:
            subprocess.run([NETSPY_CMD, "--version"], check=True, capture_output=True)
            print(f"NetSpy CLI found: {NETSPY_CMD}")
        except (subprocess.CalledProcessError, FileNotFoundError):
            print(f"NetSpy CLI '{NETSPY_CMD}' not found in PATH")
            print("NetSpy should be installed separately. Running without network tracing.")
            args.no_netspy = True

    # 1. Perform Cargo build
    print("--- Starting Cargo Build Phase ---")
    if not run_build_command(CARGO_BUILD_COMMAND.split(), "Cargo build (libraries/binaries)"): # Clarified step name
        sys.exit(1)

    # Build the specific Cargo example needed for execution
    print("--- Building vtk-cube-client-console Cargo example ---")
    cargo_example_build_command = ["cargo", "build", "--example", "vtk-cube-client-console"]
    if not run_build_command(cargo_example_build_command, "Cargo build (vtk-cube-client-console example)"):
        sys.exit(1)

    # 2. Perform CMake builds
    print("\n--- Starting CMake Build Phase ---")

    for project in CMAKE_PROJECTS_TO_BUILD:
        project_name = project['name']
        project_source_dir = project['source_dir']
        # Project-specific build directory, e.g., build/signalling-server
        project_build_dir = os.path.join(CMAKE_BUILD_DIR, project_name)

        # Clean the project-specific build directory before configuration
        if os.path.exists(project_build_dir):
            print(f"--- Cleaning existing build directory: {project_build_dir} ---")
            shutil.rmtree(project_build_dir)

        os.makedirs(project_build_dir, exist_ok=True)

        print(f"--- Configuring CMake project: {project_name} ---")
        cmake_configure_cmd = ["cmake", "-S", project_source_dir, "-B", project_build_dir] + CMAKE_CONFIG_ARGS
        if not run_build_command(cmake_configure_cmd, f"CMake configure ({project_name})", cwd=None): # cwd is root
            sys.exit(1)

        target_name = project['cmake_target_name']
        print(f"--- Building CMake project: {project_name} (Target: {target_name}) ---")
        # Build command now uses the project_build_dir
        cmake_build_cmd = ["cmake", "--build", project_build_dir, "--target", target_name]
        if not run_build_command(cmake_build_cmd, f"CMake build ({target_name})", cwd=None): # cwd is root
            sys.exit(1)
    
    print("\n--- Build phases completed ---")

    # 3. Resolve executable paths and prepare for execution
    executable_paths = {}
    for proj_spec in CMAKE_PROJECTS_TO_BUILD:
        project_name = proj_spec["name"]
        # Path to the project's specific build directory
        project_build_dir = os.path.join(CMAKE_BUILD_DIR, project_name)
        # Executable path is within its project's build directory
        path = os.path.join(project_build_dir, proj_spec["executable_relative_path"])
        if not (os.path.exists(path) and os.access(path, os.X_OK)):
            sys.stderr.write(f"Error: CMake executable '{path}' for target '{proj_spec['name']}' not found or not executable after build.\nEnsure 'executable_relative_path' is correct relative to its project's build directory.\n")
            sys.exit(1)
        executable_paths[proj_spec["name"]] = path
    
    # Prepare commands to run
    commands_to_run = []
    for run_spec in EXECUTABLE_RUN_CONFIG:
        if run_spec["type"] == "cmake":
            cmd = [executable_paths[run_spec["id"]]] + run_spec["args"]
            commands_to_run.append({
                "name": run_spec["id"],
                "cmd": cmd,
                "prefix": run_spec["prefix"]
            })
        elif run_spec["type"] == "cargo_example":
            cargo_profile = run_spec["cargo_profile"]
            example_name = run_spec["id"]
            example_path = f"target/{cargo_profile}/examples/{example_name}"
            
            if not (os.path.exists(example_path) and os.access(example_path, os.X_OK)):
                sys.stderr.write(f"Error: Cargo example executable '{example_path}' for '{example_name}' not found or not executable.\n")
                sys.exit(1)
            
            cmd = [example_path] + run_spec["args"]
            commands_to_run.append({
                "name": run_spec["id"],
                "cmd": cmd,
                "prefix": run_spec["prefix"]
            })

    # 4. Execute all processes
    try:
        # Clear any existing PCAP files
        if not args.no_netspy:
            print("--- Clearing old PCAP files ---")
            pcap_files = [f for f in os.listdir('.') if f.endswith('.pcap')]
            for pcap_file in pcap_files:
                os.remove(pcap_file)
                print(f"Removed old PCAP file: {pcap_file}")

        threads = []
        print("\n--- Starting executables in parallel ---")
        timeout_occurred = False # Flag to indicate if timeout happened

        for config in commands_to_run:
            print(f"Starting: {' '.join(config['cmd'])}")
            
            # Double-check the executable still exists with correct permissions before Popen
            if not (os.path.exists(config['cmd'][0]) and os.access(config['cmd'][0], os.X_OK)):
                 sys.stderr.write(f"Critical Error: Executable {config['cmd'][0]} for {config['name']} disappeared or lost permissions before execution.\n")
                 signal_handler(None, None) # Attempt to clean up anything already started
                 sys.exit(1)

            # Prepare command with NetSpy
            if not args.no_netspy:
                # Wrap command with netspy CLI
                final_cmd = [NETSPY_CMD, "--output", ".", "--filter", "WebRTC|RTP|UDP|TCP"] + config["cmd"]
                print(f"NetSpy tracing enabled for {config['name']}")
            else:
                final_cmd = config["cmd"]

            process = subprocess.Popen(
                final_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True
            )
            processes_to_cleanup.append(process)

            thread = threading.Thread(target=read_and_prefix_output, args=(process, config["prefix"]))
            threads.append(thread)
            thread.start()
        
        print(f"\n--- Processes running. Waiting for timeout ({args.timeout}s) or manual interruption ---")
        if not args.no_netspy:
            print("--- Network traffic will be captured in PCAP files ---")
            
        # Wait for the specified timeout
        # We'll loop with a short sleep to allow SIGINT to be processed promptly
        for _ in range(args.timeout):
            if any(p.poll() is not None for p in processes_to_cleanup):
                # A process ended prematurely, proceed to cleanup
                print("\n--- A process ended prematurely, proceeding to shutdown. ---")
                break
            time.sleep(1) # Sleep for 1 second
        else: # This else block executes if the loop completed without a break
            print(f"\n--- Timeout of {args.timeout} seconds reached. Initiating shutdown. ---")
            timeout_occurred = True
            signal_handler(None, None) # Manually trigger shutdown

        # Wait for all threads (and thus processes) to complete
        # This join will happen after timeout or if processes end on their own
        for thread in threads:
            thread.join()

        print("\n--- All processes finished or were terminated ---") # Modified message
        
        # List generated PCAP files
        if not args.no_netspy:
            print("\n--- NetSpy Network Traces Generated ---")
            pcap_files = [f for f in os.listdir('.') if f.endswith('.pcap')]
            if pcap_files:
                for pcap_file in pcap_files:
                    size = os.path.getsize(pcap_file)
                    print(f"PCAP file: {pcap_file} (size: {size} bytes)")
                print(f"\nTo analyze network traffic, use: wireshark <pcap_file>")
            else:
                print("No PCAP files were generated")
        
        all_successful = True
        for i, p in enumerate(processes_to_cleanup):
            # If a timeout occurred, a non-zero return code due to termination is expected
            # So we only consider it an "application" error if no timeout occurred
            if p.returncode != 0 and p.returncode is not None:
                if not timeout_occurred and not (hasattr(p, '_terminated_by_signal') and p._terminated_by_signal):
                    sys.stderr.write(f"Process '{commands_to_run[i]['name']}' exited with code {p.returncode}\n")
                    all_successful = False
                elif timeout_occurred and not (hasattr(p, '_terminated_by_signal') and p._terminated_by_signal):
                    # If timeout occurred, and it wasn't terminated by our signal handler (e.g. crashed before)
                    # it might still be an issue to note, but not a failure of the timeout mechanism itself.
                    print(f"Note: Process '{commands_to_run[i]['name']}' had exit code {p.returncode} after timeout.")


        if not all_successful and not timeout_occurred: # Only exit with 1 if it wasn't a planned timeout shutdown
            sys.exit(1)
        elif timeout_occurred:
            print("Shutdown due to timeout completed.")
            sys.exit(0) # Exit cleanly after a timeout

    except FileNotFoundError as e: 
        sys.stderr.write(f"FileNotFoundError during execution: {e}\n")
        signal_handler(None, None) # Try to clean up any processes already started
        sys.exit(1)
    except Exception as e:
        sys.stderr.write(f"Unexpected error during execution: {e}\n")
        signal_handler(None, None) # Try to clean up any processes already started
        sys.exit(1)

if __name__ == "__main__":
    main()